
#opengl/depth_test

在坐标系统一章中，我们渲染了一个3D容器，并使用深度缓冲来防止三角形在前面渲染，而它们应该在其他三角形后面。在本章中，我们将详细阐述深度缓冲区(或z-buffer)存储的深度值以及它如何实际确定片段是否在前面。

深度缓冲区是一个缓冲区，就像颜色缓冲区(存储所有片段颜色:视觉输出)一样，存储每个片段的信息，并且具有与颜色缓冲区相同的宽度和高度。深度缓冲区由窗口系统自动创建，并将其深度值存储为16,24或32位浮点数。在大多数系统中，你会看到一个精度为24位的深度缓冲区。

当 depth testing 被启用时，OpenGL根据深度缓冲区的内容测试片段的深度值。OpenGL执行深度测试，如果该测试通过，则渲染片段并使用新的深度值更新深度缓冲区。如果深度测试失败，则丢弃该分片。

深度测试是在碎片着色器运行后在屏幕空间中完成的(在我们将在下一章中进行的模板测试之后)。screen space coordinates直接与OpenGL的glViewport函数定义的视口相关，并且可以通过片段着色器中GLSL内置的gl_FragCoord 变量访问。gl_FragCoord 的x和y分量表示片段的屏幕空间坐标((0,0)是左下角)。gl_FragCoord 变量还包含一个z分量，其中包含片段的深度值。这个z值是与深度缓冲区的内容进行比较的值。

>如今，大多数GPU都支持称为早期深度测试的硬件功能。早期深度测试允许在碎片着色器运行之前运行深度测试。只要很清楚一个片段是不可见的（它在其他对象后面），我们就可以过早地丢弃这个片段。
>
>片段着色器通常非常昂贵，所以无论在哪里我们都应该避免运行它们。早期深度测试对片段着色器的限制是不应该写入片段的深度值。如果碎片着色器将写入其深度值，则不可能进行早期深度测试；OpenGL将无法预先计算出深度值。

深度测试默认关闭，我们需要通过 `GL_DEPTH_TEST` 来开启

```cpp
glEnable(GL_DEPTH_TEST);  
```

一旦启用，如果片段通过深度测试，OpenGL会自动将它们的z值存储在深度缓冲区中，如果片段没有通过深度测试，OpenGL会相应地丢弃片段。如果你启用了深度测试，你也应该在每帧之前使用GL深度缓冲位清除深度缓冲;否则你就只能使用上一帧的深度值.

```cpp
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
```

在某些情况下，您可能希望对所有片段执行深度测试并相应地丢弃它们，但不更新深度缓冲区。本质上，您(暂时)使用只读深度缓冲区。**OpenGL允许我们通过将深度掩码设置为GL_FALSE来禁用对深度缓冲区的写入**

```cpp
glDepthMask(GL_FALSE);  
```

ps:只有在启动depth test的时候才会开启

该函数接收以下操作

| Function    | Description                                                                              |
| ----------- | ---------------------------------------------------------------------------------------- |
| GL_ALWAYS   | The depth test always passes.                                                            |
| GL_NEVER    | The depth test never passes.                                                             |
| GL_LESS     | Passes if the fragment's depth value is less than the stored depth value.                |
| GL_EQUAL    | Passes if the fragment's depth value is equal to the stored depth value.                 |
| GL_LEQUAL   | Passes if the fragment's depth value is less than or equal to the stored depth value.    |
| GL_GREATER  | Passes if the fragment's depth value is greater than the stored depth value.             |
| GL_NOTEQUAL | Passes if the fragment's depth value is not equal to the stored depth value.             |
| GL_GEQUAL   | Passes if the fragment's depth value is greater than or equal to the stored depth value. |

默认情况下，使用深度函数GL_LESS来丢弃所有深度值高于或等于当前深度缓冲区值的片段。

我们使用 `GL_ALWAYS`

```cpp
glEnable(GL_DEPTH_TEST);
glDepthFunc(GL_ALWAYS); 
```

这模拟了如果我们不启用深度测试，我们会得到的相同行为。深度测试总是通过，所以最后绘制的片段会呈现在之前绘制的片段之前，即使它们应该在前面。由于我们最后绘制了楼层平面，因此平面的碎片会覆盖容器先前写入的每个碎片：

![](https://s2.loli.net/2023/05/19/GTBJqtcikEve5sL.png)

如果是less则

![](https://s2.loli.net/2023/05/19/F54RvKl8CGejpDt.png)

## Depth value precision

深度缓冲区包含介于0.0和1.0之间的深度值，并将其内容与从查看器中看到的场景中所有对象的z值进行比较。视图空间中的这些z值可以是投影截头体的近平面和远平面之间的任何值。因此，我们需要一些方法来将这些视图空间的z值转换到[0,1]的范围，其中一种方法是对它们进行线性转换。以下（线性）方程将z值转换为介于0.0和1.0之间的深度值：

![](https://s2.loli.net/2023/05/19/Qd8OVujNlnCB1ta.png)

near 和 far 是我们需要提供的投影矩阵的距离。

z的值和 $F_{depth}$ 之间的关系如下所示

![](https://s2.loli.net/2023/05/19/ZzNqkEgFvW2oiw6.png)

> 请注意，当物体靠近时，所有方程给出的深度值接近0.0，当物体靠近远平面时，所有方程给出的深度值接近1.0。

但是在实际情况中，这种线性的缓冲器几乎没有使用，由于投影特性，使用与1/z成比例的非线性深度方程。结果是，当z很小时，我们得到了巨大的精度，而当z很远时，我们得到的精度要低得多。

由于非线性函数与1/z成比例，因此1.0和2.0之间的z值将导致1.0和0.5之间的深度值，这是[0,1]范围的一半，在较小的z值下给我们带来了巨大的精度。50.0和100.0之间的Z值仅占[0,1]范围的2%。下面给出了这样一个方程，它也考虑了近距离和远距离：

![](https://s2.loli.net/2023/05/19/FfVJdC9co1ybWuZ.png)

如果你不知道这个方程到底发生了什么，不要担心。需要记住的重要一点是，深度缓冲区中的值在剪辑空间中不是线性的（在应用投影矩阵之前，它们在视图空间中是线性的）。深度缓冲器中的值0.5并不意味着像素的z值在截头体中的一半；顶点的z值实际上非常接近近平面！您可以在下图中看到z值和生成的深度缓冲区值之间的非线性关系：

![](https://s2.loli.net/2023/05/19/a6B2LbR49spPfWu.png)


正如你所看到的，深度值在很大程度上取决于小的z值，这给了我们对附近物体的大深度精度。转换z值的方程（从观看者的角度来看）嵌入在投影矩阵中，因此当我们将顶点坐标从视图转换到剪辑，然后转换到屏幕空间时，会应用非线性方程。

当我们试图可视化深度缓冲区时，这个非线性方程的效果很快变得明显。

## 可视化深度缓冲区

我们知道片段着色器中内置 `gl_FragCoord` 向量的z值包含特定片段的深度值。如果我们将片段的这个深度值输出为颜色，我们可以显示场景中所有片段的深度值：

```glsl
void main()
{             
    FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
}  
```

如果你运行这个程序，你可能会注意到所有的东西都是白色的，看起来我们所有的深度值都是1.0的最大深度值。那么为什么没有任何深度值更接近0.0，从而更暗呢

在上一节中，我们描述了屏幕空间中的深度值是非线性的，例如，它们对于小z值具有非常高的精度，而对于大z值具有低的精度。片段的深度值随着距离的增加而迅速增加，因此几乎所有顶点的值都接近1.0。如果我们小心地移动到离物体很近的地方，你最终可能会看到颜色越来越深，它们的z值越来越小：

![](https://s2.loli.net/2023/05/19/Wda78i3G14jUzsV.png)

这清楚地显示了深度值的非线性。近处的物体比远处的物体对深度值的影响要大得多。只要移动几英寸，颜色就会从深色变成完全的白色。

然而，我们可以将片段的非线性深度值转换回其线性同级。为了实现这一点，我们基本上需要反转仅针对深度值的投影过程。这意味着我们必须首先将深度值从[0,1]范围重新转换为[-1,1]范围内的归一化设备坐标。然后，我们想反转非线性方程（方程2），就像在投影矩阵中所做的那样，并将这个反转的方程应用于所得到的深度值。结果就是一个线性深度值。

首先，我们将深度值转换为NDC，这并不太难

```glsl
float ndc = depth * 2.0 - 1.0; 
```

然后，我们取得到的ndc值并应用逆变换来检索其线性深度值

```glsl
float linearDepth = (2.0 * near * far) / (far + near - ndc * (far - near));	
```

该方程由投影矩阵导出，用于非线性化深度值，返回远近之间的深度值。这篇数学含量很高的文章为感兴趣的读者详细解释了投影矩阵;它还显示了方程的来源。

将屏幕空间中的非线性深度转换为线性深度值的完整片段着色器如下所示：

```glsl
#version 330 core
out vec4 FragColor;

float near = 0.1; 
float far  = 100.0; 
  
float LinearizeDepth(float depth) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));	
}

void main()
{             
    float depth = LinearizeDepth(gl_FragCoord.z) / far; // divide by far for demonstration
    FragColor = vec4(vec3(depth), 1.0);
}
```

因为线性化的深度值范围从近到远，所以它的大多数值都将在1.0以上，并显示为完全白色。通过在主函数中将线性深度值除以远，我们将线性深度值转换为范围[0，1]。通过这种方式，我们可以逐渐看到fragment离投影截头体的远平面越近，场景就越亮，这对于可视化来说效果更好。

如果我们现在运行应用程序，我们得到的深度值与距离成线性关系。尝试在场景中移动，看看深度值以线性方式变化。

颜色大多是黑色的，因为深度值从近平面（0.1）到离我们很远的远平面（100）呈线性变化。结果是，我们离近平面相对较近，因此深度值较低（较暗）。

![](https://s2.loli.net/2023/05/19/12RTnOLMXYA5UaQ.png)


## z-fighting

当两个平面或三角形彼此紧密对齐，以至于深度缓冲区没有足够的精度来判断两个形状中的哪一个在另一个前面时，可能会出现常见的视觉伪影。结果是，这两个形状似乎不断地切换顺序，这导致了奇怪的故障模式。这被称为z-fighting，因为它看起来像是形状在争夺谁能上位。

在我们目前使用的场景中，有几个地方可以注意到z战。容器被放置在地板的确切高度，这意味着容器的底部平面与地板平面共面。两个平面的深度值是相同的，因此最终的深度测试无法确定哪一个是正确的。

如果在其中一个容器内移动相机，效果会清晰可见，容器的底部会以Z字形模式在容器的平面和地板的平面之间不断切换：

Z-fighting是深度缓冲的一个常见问题，当物体较远时，它通常更明显(因为深度缓冲在较大z值时精度较低)。z型打斗无法完全阻止，但有一些技巧可以帮助你减轻或完全防止场景中的z型打斗。

![](https://s2.loli.net/2023/05/19/befJExzH97OlDs5.png)


### Prevent z-fighting

第一个也是最重要的技巧是永远不要把物体放得太近，使它们的一些三角形紧密重叠。通过在两个对象之间创建一个小的偏移，可以完全消除两个对象间的z向冲突。在集装箱和飞机的情况下，我们可以很容易地将集装箱向正y方向稍微向上移动。集装箱位置的微小变化可能根本不会引起注意，并且会完全减少z战。然而，这需要对每个对象进行手动干预，并进行彻底的测试，以确保场景中没有对象产生z战斗。

第二个技巧是将近平面设置得尽可能远。在前面的一节中，我们已经讨论过，当接近近平面时，精度非常大，所以如果我们将近平面从观察者移开，我们将在整个截头体范围内获得更高的精度。然而，将近平面设置得太远可能会导致近对象的剪裁，因此通常需要进行调整和实验才能找出场景的最佳近距离。

另一个以牺牲一些性能为代价的伟大技巧是使用更高精度的深度缓冲区。大多数深度缓冲器的精度为24位，但现在大多数GPU支持32位深度缓冲器，从而大大提高了精度。因此，以牺牲一些性能为代价，通过深度测试可以获得更高的精度，从而减少z战。

我们讨论过的3种技术是最常见、最容易实现的反z战斗技术。还有一些其他技术需要做更多的工作，但仍然不能完全禁用z战。Z-fighting是一个常见的问题，但如果你使用了所列技术的正确组合，你可能就不需要那么多地处理Z-fightion了。