# basic lighting

#opengl/lighting

现实生活中的关照往往很复杂，难以计算。

因此opengl基于现实中的近似情况，使用更加简单的模型使效果看起来和现实类似。

有一个被称为冯照明模型。包含三个要素：ambient, diffuse and specular lighting

![](https://s2.loli.net/2023/03/13/WNUKd4fAJGFvmoB.png)

Ambient lighting(环境光)：哪怕使黑暗环境都有一些光源如：月亮等等等，因此物体往往不是全黑的，我们通过使用常数来给物体环境光

Diffuse lighting(漫反射光)：模拟灯光对象对对象的方向影响。这是照明模型中视觉上最重要的组成部分。对象的一部分越面向光源，它就越亮。

Specular lighting(镜面照明)：模仿出现在闪亮物体上的光的亮点。高光更倾向于光的颜色而不是物体的颜色。

# Ambient lighting环境照明

#opengl/lighting/ambient

生活中，光源不是来自一个光源。光的特征之一是它可以向多个方向散射和反弹，到达无法直接看到的点；因此，光可以在其他表面上反射，并对物体的照明产生间接影响。

考虑到这一点的算法被称为全局照明算法，但这些算法既复杂又昂贵。

将环境光添加到场景中非常容易。我们获取灯光的颜色，将其乘以一个小的恒定环境因子，将其与对象的颜色相乘，并将其用作立方体对象着色器中片段的颜色：

```c++
void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 result = ambient * objectColor;
    FragColor = vec4(result, 1.0);
}  
```

如果现在运行该程序，您将注意到第一阶段照明现在已成功应用于对象。该对象非常暗，但由于应用了环境光，因此并不完全暗（请注意，由于我们使用了不同的着色器，因此光立方体不受影响）

# Diffuse lighting 漫反射

#opengl/lighting/diffuse

环境照明本身并不能产生最有趣的结果，但是漫射照明将开始对物体产生重要的视觉影响。漫射照明使物体的碎片越接近光源的光线，亮度就越高。为了让你更好地理解漫射照明，看看下面的图像

![](https://s2.loli.net/2023/03/14/RQNafGEoA1PzSXY.png)

左侧有一个光源，光源瞄准了一个片段，我们需要知道光线接触片段的角度。如果光线和物体表面是垂直的，那么光线会最大程度反射。为了测量光线和碎片之间的角度，我们使用了一个叫做法向量的东西，这是一个垂直于碎片表面的向量(这里用黄色箭头表示);我们稍后会讲到。两个向量之间的夹角可以很容易地用点积计算出来。

在前面的章节中，the lower the angle between two unit vectors, the more the dot product is inclined towards a value of 1.

 When the angle between both vectors is 90 degrees, the dot product becomes 0.

The same applies to θ: the larger θ becomes, the less of an impact the light should have on the fragment's color.

> 简单来说，如果两个向量的点集越大 ---- 夹角越小 ---- 反射的光越多

> 请注意，为了(仅)得到两个向量夹角的余弦，我们将使用单位向量(长度为1的向量)，因此我们需要确保所有向量都是标准化的，否则点积返回的不仅仅是余弦(参见转换)。

因此，生成的点积返回一个标量，我们可以使用该标量来计算灯光对碎片颜色的影响，从而根据碎片朝向灯光的方向产生不同的照明碎片。

计算过程

- normal vectors单位向量：一个垂直于表面的向量
- The directed light ray(定向光线)：一个方向向量，它是光的位置和碎片位置之间的差向量。为了计算这条光线，我们需要光的位置向量和碎片的位置向量。

### normal vectors

因为顶点本身没有表面，我们通过使用它周围的顶点来获取一个法向量，以计算出顶点的曲面。我们可以使用一个小技巧，通过计算叉乘来给所有物体的顶点找到法向量，但由于3D立方体不是一个复杂的形状，我们可以简单地手动将它们添加到顶点数据

```c++
float vertices[] = {
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
    -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 

    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,

    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,

     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,

    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f
};
```

我们需要在shader中加入需要的数据

```glsl
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
```

我们不需要更新光源的着色器或属性配置，但我们必须至少修改顶点属性指针，以反映新的顶点数组的大小

```c++
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
```

We only want to use the first `3` floats of each vertex and ignore the last `3` floats so we only need to update the *stride* parameter to `6` times the size of a `float` and we're done.

所有光线计算都在片段shader中，因此我们需要将法向量传递到片段shader中

```glsl
out vec3 Normal;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    Normal = aNormal;
}
```

What's left to do is declare the corresponding input variable in the fragment shader:

```glsl
in vec3 Normal;  
```

### 计算漫射颜色

我们有了法向量，但是我们还需要知道光源和片段位置的差向量。因为光的位置是一个单一的静态变量，我们可以在片段着色器中声明它为统一的置

```glsl
uniform vec3 lightPos;  
```

然后更新渲染循环中的uniform（或外部，因为它不会每帧更改）。我们使用上一章中声明的lightPos向量作为漫反射光源的位置：

```c++
lightingShader.setVec3("lightPos", lightPos);  
```

最后一件事就是现实片段的位置。

我们将在世界空间中进行所有的照明计算，所以我们希望顶点位置首先位于世界空间中。我们可以通过将顶点位置属性仅与模型矩阵（而不是视图和投影矩阵）相乘，将其转换为世界空间坐标来实现这一点。这可以在顶点着色器中轻松完成，因此让我们声明一个输出变量并计算其世界空间坐标：

```glsl
out vec3 FragPos;  
out vec3 Normal;
  
void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = aNormal;
}
```

最后将相应的输入变量添加到片段着色器中

```glsl
in vec3 FragPos;  
```

该in变量将从三角形的3个世界位置向量中插值，以形成FragPos向量，即每个片段的世界位置。现在设置了所有必需的变量，我们可以开始照明计算。

```glsl
vec3 norm = normalize(Normal);
vec3 lightDir = normalize(lightPos - FragPos);  
```

> 在计算照明时，我们通常不关心矢量的大小或它们的位置；我们只关心他们的方向。因为我们只关心它们的方向，所以几乎所有的计算都是用单位向量完成的，因为它简化了大多数计算（如点积）。因此，在进行照明计算时，请确保始终规范化相关向量，以确保它们是实际的单位向量。忘记规范化向量是一个常见的错误。

接下来，我们需要通过取norm和lightDir向量之间的点积来计算灯光对当前片段的漫反射影响。然后将得到的值与光的颜色相乘得到漫反射分量，导致两个矢量之间的角度越大，漫反射分量越暗

```glsl
float diff = max(dot(norm, lightDir), 0.0);
vec3 diffuse = diff * lightColor;
```

如果夹角超过90度，那么cos的值就是负数，我们最终得到一个负扩散分量。因此我们需要使用max函数，将值的范围控制在0.0之上。负面色彩的照明并没有真正定义，所以最好远离它，除非你是那些古怪的艺术家之一。

现在我们有了环境光和漫反射组件，我们将两种颜色相加，然后将结果与对象的颜色相乘，以获得结果片段的输出颜色：

```glsl
vec3 result = (ambient + diffuse) * objectColor;
FragColor = vec4(result, 1.0);
```

## 最后一件事

#opengl/lighting/normalize_model

在上一节中，我们将法线向量直接从顶点着色器传递到片段着色器。然而，碎片着色器中的计算都是在世界空间中完成的，所以我们不应该将法线向量也转换为世界空间坐标吗？基本上是的，但这并不像简单地将其与模型矩阵相乘那么简单。

首先，法向量只是方向向量，并不代表空间中的特定位置。第二，法向量没有齐次坐标(顶点位置的w分量)。这意味着平移对法向量没有任何影响。因此，如果我们想要将法向量与模型矩阵相乘，我们想要通过取模型矩阵的左上角3x3矩阵来去除矩阵的平移部分(注意，我们也可以将法向量的w分量设置为0并与4x4矩阵相乘)。

其次，如果模型矩阵将执行非均匀缩放，顶点将以这样一种方式改变，即法向量不再垂直于曲面。下图显示了这样一个模型矩阵(具有非均匀缩放)对法向量的影响

![](https://s2.loli.net/2023/03/15/NiYWv9D83dTF4lM.png)

当我们使用非均匀尺度时(注意:均匀尺度只改变法线的大小，而不改变它的方向，这很容易通过标准化来固定)，法向量不再垂直于相应的表面，这就扭曲了光照。

修复这种行为的技巧是使用一个专门为法向量定制的不同模型矩阵。这个矩阵被称为法向量矩阵，并使用一些线性代数运算来消除法向量缩放错误的影响。如果你想知道这个矩阵是如何计算的，我建议你看下面的文章。

http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/

法矩阵被定义为“模型矩阵的左上3x3部分的逆的转置”。唷，这有点拗口，如果你不明白这是什么意思，别担心;我们还没有讨论逆矩阵和转置矩阵。注意，大多数资源将标准矩阵定义为从模型-视图矩阵派生的，但由于我们是在世界空间(而不是视图空间)中工作，所以我们将从模型矩阵派生它。

注意，我们将矩阵转换为3x3矩阵，以确保它失去平移属性，并且可以与vec3法向量相乘

```c++
Normal = mat3(transpose(inverse(model))) * aNormal;  
```

我们使用`inverse`和`transpose`方法.

> 对着色器来说，逆矩阵是一项代价高昂的操作，因此尽可能避免执行逆操作，因为它们必须在场景的每个顶点上执行。出于学习目的，这是可以的，但对于高效的应用程序，您可能需要在绘制之前计算CPU上的法线矩阵，并通过统一的方式将其发送到着色器（就像模型矩阵一样）。

在漫射照明部分，照明是好的，因为我们没有在物体上做任何缩放，所以真的不需要使用法向矩阵，我们可以只是将法向矩阵与模型矩阵相乘。然而，如果你在做一个非均匀的缩放，你的法向量与法矩阵相乘是很重要的。

## 总结

```glsl
//vs
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;//输入法向量

out vec3  Normal;//输出法向量
out vec3  FragPos;//输出顶点位置

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;



void main()
{
	gl_Position = projection * view * model * vec4(aPos, 1.0);
	//输出向量
	FragPos = vec3(model * vec4(aPos, 1.0));
	Normal = mat3(transpose(inverse(model))) * aNormal; //法向量矩阵 --- 防止在拉伸的时候不垂直
}

//fs
#version 330 core
out vec4 FragColor;

//对应输入
in vec3 Normal;
in vec3 FragPos;

//物体本身的颜色
uniform vec3 objectColor;
uniform vec3 lightColor;//光的颜色

uniform vec3 lightPos;//光源位置

void main()
{
//环境光 --- 0.1
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;//环境光下的颜色

    //diffuse lighting
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);//得到光照的向量
    //calculate 光照方向和法向量的夹角
    float diff = max(dot(norm, lightDir), 0.0); //dot 的结果是cos值
    vec3 diffuse = diff * lightColor;//光照的颜色

    vec3 result = (ambient + diffuse) * objectColor;//光的颜色*物体本身的颜色
    FragColor = vec4(result, 1.0);//返回结果
}


```


## Specular Lighting 镜面照明

#opengl/lighting/specular

和漫反射相似，镜面反射也是基于光线位置和物体的法向量。但是这次还基于视口的方向

玩家从哪个方向看碎片。镜面反射照明基于曲面的反射财产。如果我们将物体的表面视为镜子，那么无论我们在哪里看到反射在表面上的光，镜面照明都是最强的。您可以在下图中看到这种效果：

<img src="https://s2.loli.net/2023/03/15/zFEerc2AxCYvT4q.png" style="zoom:33%;" />

我们先通过法向量得到光线的反射向量。之后计算反射向量和视角方向的夹角。夹角越小，镜面反射越强烈。由此产生的效果是，当我们观察光通过表面反射的方向时，我们看到了一点高光。

视图向量是一个额外的变量，我们需要高光照明，我们可以计算使用观众的世界空间位置和碎片的位置。然后我们计算镜面的强度，将其与光线颜色相乘，并将其添加到环境和漫反射组件中。

> 我们选择在世界空间中进行照明计算，但大多数人倾向于在视图空间中进行灯光计算。视图空间的一个优点是，查看器的位置总是在（0,0,0），所以您已经免费获得了查看器的位置。然而，我发现计算世界空间中的照明对于学习来说更直观。如果仍要计算视图空间中的照明，则还需要使用视图矩阵变换所有相关向量（也不要忘记更改法线矩阵）。

为了得到世界空间内的相机视线向量。

所以让我们在片段着色器中添加另一个uniform，并将相机位置向量传递给着色器

```glsl
uniform vec3 viewPos;
```

```c++
lightingShader.setVec3("viewPos", camera.Position); 
```

我们现在有了所有向的变量，我们可以先定义一个镜面强度值来给镜面反射光一个中亮的颜色，物体就不会收到太大的影响

```glsl
float specularStrength = 0.5;
```

如果我们将这个设置为1.0f，我们会得到一个非常明亮的镜面组件，这对于立方体来说有点太多了。之后我们需要计算视口方向向量以及相对应的反射向量

```glsl
vec3 viewDir = normalize(viewPos - FragPos);//视角向量
vec3 reflectDir = reflect(-lightDir, norm);  //光线反射向量
```

**注意：** 我们将lightdir的值置为负，因为反射函数希望第一个向量参数从光源指向片段，但是lightDir当前已另一种方式：从片段指向光源(这是因为我们之前计算lightDir的时候的顺序)，因此我们需要通过-1来逆转向量的方向。第二个值希望要一个法向量。

接下来计算镜面反射䛾

```glsl
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
vec3 specular = specularStrength * spec * lightColor;  
```

- 实现我们计算点积，并使用max确保值为正
- 然后去32的幂

32是是高亮的亮度值，亮度值越高，反射的光线越多，而不是散乱的反射的到处都是导致观点越小。

![](https://s2.loli.net/2023/03/16/N9GiLIMJHgomvVf.png)

我们不希望镜面反射分量过于分散注意力，所以我们将指数保持在32。唯一要做的就是将其添加到环境光和漫反射组件中，并将组合结果与对象的颜色相乘：

```glsl
vec3 result = (ambient + diffuse + specular) * objectColor;
FragColor = vec4(result, 1.0);
```

> 在早期的照明着色器中，开发人员曾在顶点着色器中实现Phong照明模型。在顶点着色器中进行照明的优势在于，它的效率要高得多，因为与片段相比，顶点通常要少得多，因此（昂贵的）照明计算的执行频率也更低。但是，顶点着色器中的最终颜色值仅是该顶点的最终照明颜色，而周围片段的颜色值则是插值照明颜色的结果。结果是，除非使用大量顶点，否则照明不是很逼真：
>
> 当Phong照明模型在顶点着色器中实现时，它被称为Gouraud着色，而不是Phong着色。请注意，由于插值的原因，照明看起来有些不对劲。Phong明暗处理可以提供更平滑的照明效果。
>
> <img src="https://s2.loli.net/2023/03/16/kSRNaOx3LmsuPgH.png" style="zoom:33%;" />


### 总结

specular lighting 不涉及 vs

输入一个视角尺度 

```glsl
#version 330 core
out vec4 FragColor;

//对应输入
in vec3 Normal;
in vec3 FragPos;

//物体本身的颜色
uniform vec3 objectColor;
uniform vec3 lightColor;//光的颜色

uniform vec3 lightPos;//光源位置

//镜像反射
uniform vec3 viewPos;


void main()
{
    //环境光 --- 0.1
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;//环境光下的颜色

    //diffuse lighting
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);//得到光照的向量
    //calculate 光照方向和法向量的夹角
    float diff = max(dot(norm, lightDir), 0.0); //dot 的结果是cos值
    vec3 diffuse = diff * lightColor;//光照的颜色

    //specular lighting
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);//视角向量
    vec3 reflectDir = reflect(-lightDir, norm);  //光线反射向量

    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);//反射值 --- 光圈大小
    vec3 specular = specularStrength * spec * lightColor;


    vec3 result = (ambient + diffuse + specular) * objectColor;//光的颜色*物体本身的颜色
    FragColor = vec4(result, 1.0);//返回结果
}
```